'''Needs docs'''


import numpy as np
from experiment import LogExperiment, TrialTypes
import re

def trialtype(exp):
    assert isinstance(exp, LogExperiment), "Cannot report on non-logged experiments"
    ttypes = exp.trial_types if isinstance(exp, TrialTypes) else ["trial"]
    trials = dict([(t, dict(correct=[], incorrect=[], timeout=[])) for t in ttypes])
    report = dict(rewards=0, prematures=[], trials=trials)
    trial = None

    for state, event, t in exp.event_log:
        if trial is not None:
            if "incorrect" in event:
                report['trials'][state]["incorrect"].append(t - trial)
            elif "correct" in event:
                report['trials'][state]["correct"].append(t - trial)
            elif "timeout" in event:
                report['trials'][state]["timeout"].append(t - trial)
            trial = None
        
        if event == "start_trial":
            trial = t
        elif state == "reward":
            report['rewards'] += 1
    
    return report

def general(Exp, event_log, ntrials, nrewards, reward_len):
    report = dict(trials = 0, reward_len=[]) #, rewards=[], penalties=[])

    report['trials'] = ntrials
    report['reward_len'] = reward_len, nrewards

    #if len(event_log) > 0:
    #    report['length'] = event_log[-1][2] - event_log[0][2]

    # trial = None
    # last_reward = None
    # for state, event, t in event_log:
    #     next_state = Exp.status[state][event]
    #     if state == "wait":
    #         report['trials'] += 1
    #     if "start_trial" in event:
    #         trial = t

    #     if trial is not None and next_state is not None:
    #         if "reward" in next_state:
    #             report['rewards'].append(t - trial)
    #             last_reward = t
    #             trial = None
    #         elif "penalty" in next_state:
    #             report['penalties'].append(t - trial)
    #             trial = None
    #     elif last_reward is not None:
    #         report['reward_len'].append(t - last_reward)
    #         last_reward = None

    if report['trials'] == 0:
        report['rates'] = (0,0)
    else:
       report['rates'] = (float(nrewards)/ntrials, 1-(float(nrewards)/ntrials))
    #     report['rates'] = (len(report['rewards']) / float(report['trials']), 
    #                       len(report['penalties']) / float(report['trials']))

    # report['reward_len'] = sum(report['reward_len']), len(report['reward_len'])
    # try:
    #     c, e = np.histogram(report['rewards'])
    #     report['reward_hist'] = zip(e, c.tolist())
    #     c, e = np.histogram(report['penalties'])
    #     report['penalty_hist'] = zip(e, c.tolist())
    # except:
    #     pass
        
    return report

def general_offline(Exp, event_log):
    '''
    Generate report for an experiment after it has finished running
    TODO this seems like it should be an attribute of the task
    '''
    report = dict(trials=0, reward_len=[])
    n_trials = 0
    n_success_trials = 0
    n_error_trials = 0
    reward_time = 0

    start_time = event_log[0][-1]
    for k, (state, event, t) in enumerate(event_log):
        next_state = Exp.status[state][event]
        if state == "reward":
             n_trials += 1
             n_success_trials += 1
             reward_time += (t - event_log[k-1][2])
        elif re.match('.*?_penalty', state):
             n_trials += 1
             n_error_trials += 1
    report['trials'] = n_trials
    if n_trials > 0:
        report['rates'] = (float(n_success_trials)/n_trials, float(n_error_trials)/n_trials)
    else:
        report['rates'] = (0., 0.)
    report['reward_len'] = (reward_time, n_success_trials)
    report['length'] = t - start_time
    return report


def print_report(report):
    '''Prints a report generated by report(exp)'''
    repstr = ["%8s: %d"%("rewards", report['rewards'])]
    ttrial = 0
    for tname, tdict in report['trials'].items():
        total = len(tdict['correct']) + len(tdict['incorrect']) + len(tdict['timeout'])
        ttrial += total
        if total == 0:
            cper = 0
        else:
            cper = float(len(tdict['correct'])) / total * 100
        cRT = np.mean(tdict['correct'])
        repstr.append("%8s: %g%%, RT=%g"%(tname, cper, cRT))
    repstr.insert(0, "%8s: %d"%("total", ttrial))
    print "\n".join(repstr)
